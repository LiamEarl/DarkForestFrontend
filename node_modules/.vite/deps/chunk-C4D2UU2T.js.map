{
  "version": 3,
  "sources": ["../../pixi.js/src/extensions/Extensions.ts", "../../pixi.js/src/ticker/const.ts", "../../pixi.js/src/ticker/TickerListener.ts", "../../pixi.js/src/ticker/Ticker.ts"],
  "sourcesContent": ["/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n\n    /** A type of extension for creating custom batchers used in rendering. */\n    Batcher = 'batcher',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Mixin the source object into the target object.\n     * @param Target - The target object to mix into.\n     * @param sources - The source(s) object to mix from\n     */\n    mixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][])\n    {\n        // Apply each source's properties to the target prototype\n        for (const source of sources)\n        {\n            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));\n        }\n    }\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n"],
  "mappings": "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",
  "names": ["ExtensionType", "extensions", "UPDATE_PRIORITY", "_Ticker"]
}
